---
description: Detailed reference documentation for advanced usage and edge cases
globs: []
tags:
  - reference
  - advanced
  - detailed
  - edge-cases
priority: 3
version: 1.0.0
alwaysApply: false
---

# Detailed Technical Reference

Use this file for deep dives into specific technologies, advanced patterns, and edge cases.

---

## SvelteKit Advanced Patterns

### Performance Optimizations

SvelteKit includes these by default:

1. **Code Splitting**: Each route loads only its required code
2. **Asset Preloading**: Links preload assets before navigation
3. **File Hashing**: Enables aggressive caching with content hashes
4. **Request Coalescing**: Combines multiple data fetches into one HTTP request
5. **Parallel Loading**: Fetches data simultaneously when possible
6. **Data Inlining**: Embeds fetch results in HTML to avoid duplicate requests
7. **Conservative Invalidation**: Re-fetches only when dependencies change
8. **Prerendering**: Generates static HTML for SEO and instant loads
9. **Link Preloading**: Hovers trigger prefetching of next page

Additional tips:

- Use `preloadData()` for critical navigation paths
- Implement proper caching headers in `+server.ts` files
- Use `$app/navigation` for client-side navigation
- Lazy load heavy components with dynamic imports
- Optimize images (consider `@sveltejs/enhanced-img`)

### Authentication Patterns

#### Session-Based (Database-Backed)

```typescript
// hooks.server.ts
export async function handle({ event, resolve }) {
	const sessionId = event.cookies.get('session');

	if (sessionId) {
		event.locals.user = await db.session.findUnique({
			where: { id: sessionId },
			include: { user: true }
		});
	}

	return resolve(event);
}
```

**Pros**: Immediate revocation, centralized control
**Cons**: Database query on every request

#### Token-Based (JWT)

```typescript
// hooks.server.ts
import jwt from 'jsonwebtoken';

export async function handle({ event, resolve }) {
	const token = event.cookies.get('token');

	if (token) {
		try {
			event.locals.user = jwt.verify(token, SECRET);
		} catch {}
	}

	return resolve(event);
}
```

**Pros**: No database queries, stateless, better performance
**Cons**: Cannot immediately revoke, token size limits

---

## Svelte 5 Advanced Runes

### `$state.raw()` - Shallow Reactivity

Use when you don't need deep reactivity:

```svelte
<script>
	// Deep reactivity (default)
	let user = $state({ name: 'Alice', profile: { age: 30 } });
	user.profile.age = 31; // Triggers reactivity

	// Shallow reactivity
	let data = $state.raw({ name: 'Bob', profile: { age: 40 } });
	data.profile.age = 41; // Does NOT trigger reactivity
	data = { name: 'Bob', profile: { age: 41 } }; // DOES trigger
</script>
```

**When to use**: Large immutable objects, performance-critical paths

### `$state.snapshot()` - Plain Object Copy

```svelte
<script>
	let user = $state({ name: 'Alice', age: 30 });

	// Pass to external API that doesn't handle proxies
	const snapshot = $state.snapshot(user);
	externalAPI.send(snapshot); // Plain object, not reactive proxy
</script>
```

**When to use**: External APIs, serialization, debugging

### `$effect.pre()` - Pre-DOM Effects

```svelte
<script>
	let element;
	let messages = $state([]);

	// Run BEFORE DOM updates (rare, for scroll position preservation)
	$effect.pre(() => {
		if (!element) return;
		const scrollPos = element.scrollTop;

		return () => {
			// Restore scroll position after DOM update
			element.scrollTop = scrollPos;
		};
	});
</script>
```

**When to use**: Scroll position preservation, measuring before DOM changes

### `$effect.tracking()` - Debug Reactivity

```svelte
<script>
	let count = $state(0);

	$effect(() => {
		console.log('Tracking:', $effect.tracking()); // true
		console.log('Count:', count);
	});

	// Outside effect
	console.log('Tracking:', $effect.tracking()); // false
</script>
```

**When to use**: Debugging reactivity issues, conditional reactivity

### `$effect.root()` - Manual Effect Management

```svelte
<script>
	import { onMount } from 'svelte';

	let cleanup;

	onMount(() => {
		cleanup = $effect.root(() => {
			let count = $state(0);

			$effect(() => {
				console.log('Count:', count);
			});

			return () => {
				console.log('Root cleanup');
			};
		});
	});

	function destroy() {
		cleanup?.(); // Manually cleanup effects
	}
</script>
```

**When to use**: Dynamic effect creation, manual lifecycle control

---

## Convex Advanced Patterns

### Pagination

```typescript
// convex/posts.ts
export const listPaginated = query({
	args: {
		paginationOpts: paginationOptsValidator
	},
	handler: async (ctx, args) => {
		return await ctx.db.query('posts').order('desc').paginate(args.paginationOpts);
	}
});
```

```svelte
<script>
	import { usePaginatedQuery } from 'convex-svelte';

	const { results, status, loadMore } = usePaginatedQuery(
		api.posts.listPaginated,
		{},
		{ initialNumItems: 20 }
	);
</script>
```

### Actions (External APIs)

```typescript
// convex/notifications.ts
import { action } from './_generated/server';
import { v } from 'convex/values';

export const sendEmail = action({
	args: {
		to: v.string(),
		subject: v.string(),
		body: v.string()
	},
	handler: async (ctx, args) => {
		// Can use fetch, access env vars
		const response = await fetch('https://api.sendgrid.com/v3/mail/send', {
			method: 'POST',
			headers: {
				Authorization: `Bearer ${process.env.SENDGRID_KEY}`,
				'Content-Type': 'application/json'
			},
			body: JSON.stringify({
				to: args.to,
				subject: args.subject,
				html: args.body
			})
		});

		// Can call mutations
		await ctx.runMutation(api.notifications.markSent, {
			email: args.to
		});

		return response.ok;
	}
});
```

### Scheduled Functions (Cron Jobs)

```typescript
// convex/crons.ts
import { cronJobs } from 'convex/server';
import { internal } from './_generated/api';

const crons = cronJobs();

// Run every day at midnight
crons.daily('clean-old-posts', { hourUTC: 0, minuteUTC: 0 }, internal.posts.cleanOldPosts);

// Run every hour
crons.hourly('send-digest', { minuteUTC: 0 }, internal.emails.sendDigest);

// Custom schedule
crons.cron(
	'weekly-report',
	'0 9 * * 1', // Every Monday at 9am
	internal.reports.generate
);

export default crons;
```

### File Storage

```typescript
// Generate upload URL
export const generateUploadUrl = mutation(async (ctx) => {
	return await ctx.storage.generateUploadUrl();
});

// Save file reference
export const saveFile = mutation({
	args: { storageId: v.id('_storage'), name: v.string() },
	handler: async (ctx, args) => {
		return await ctx.db.insert('files', {
			storageId: args.storageId,
			name: args.name,
			uploadedAt: Date.now()
		});
	}
});

// Get file URL
export const getFileUrl = query({
	args: { storageId: v.id('_storage') },
	handler: async (ctx, args) => {
		return await ctx.storage.getUrl(args.storageId);
	}
});
```

```svelte
<script>
	import { useMutation, useQuery } from 'convex-svelte';
	import { api } from '../convex/_generated/api';

	const generateUploadUrl = useMutation(api.files.generateUploadUrl);
	const saveFile = useMutation(api.files.saveFile);

	async function handleUpload(file: File) {
		// 1. Get upload URL
		const uploadUrl = await generateUploadUrl();

		// 2. Upload file
		const result = await fetch(uploadUrl, {
			method: 'POST',
			body: file
		});

		const { storageId } = await result.json();

		// 3. Save reference
		await saveFile({ storageId, name: file.name });
	}
</script>
```

---

## Runed Advanced Utilities

### Debounced & Throttled

```svelte
<script>
	import { Debounced, Throttled } from 'runed';

	let searchQuery = $state('');
	const debouncedQuery = new Debounced(() => searchQuery, 300);

	let scrollPos = $state(0);
	const throttledScroll = new Throttled(() => scrollPos, 100);

	$effect(() => {
		// Only runs 300ms after user stops typing
		console.log('Searching for:', debouncedQuery.current);
	});
</script>
```

### Finite State Machine

```svelte
<script>
	import { FiniteStateMachine } from 'runed';

	const machine = new FiniteStateMachine('idle', {
		idle: {
			start: 'loading'
		},
		loading: {
			success: 'loaded',
			error: 'error'
		},
		loaded: {
			refresh: 'loading'
		},
		error: {
			retry: 'loading'
		}
	});

	// machine.current.state
	// machine.current.transition('start')
</script>
```

### Intersection Observer

```svelte
<script>
	import { useIntersectionObserver } from 'runed';

	let element;
	const observer = useIntersectionObserver(
		() => element,
		(entries) => {
			if (entries[0].isIntersecting) {
				console.log('Element visible!');
			}
		},
		{ threshold: 0.5 }
	);
</script>

<div bind:this={element}>Observe me</div>
```

---

## Better Auth Advanced

### Two-Factor Authentication

```typescript
// Enable 2FA in config
export const auth = betterAuth({
	twoFactor: {
		enabled: true,
		issuer: 'YourApp'
	}
});
```

```svelte
<script>
	import { authClient } from '$lib/auth.client';

	async function enable2FA() {
		const { qrCode, secret } = await authClient.twoFactor.generate();
		// Show QR code to user
	}

	async function verify2FA(code: string) {
		await authClient.twoFactor.verify({ code });
	}

	async function disable2FA() {
		await authClient.twoFactor.disable();
	}
</script>
```

### Password Reset

```svelte
<script>
	import { authClient } from '$lib/auth.client';

	let email = $state('');
	let resetToken = $state('');
	let newPassword = $state('');

	async function requestReset() {
		await authClient.forgetPassword({ email });
		// Email sent with reset link
	}

	async function resetPassword() {
		await authClient.resetPassword({
			token: resetToken,
			password: newPassword
		});
	}
</script>
```

### Session Management

```svelte
<script>
	import { authClient } from '$lib/auth.client';

	async function signOut() {
		await authClient.signOut();
		window.location.href = '/';
	}

	async function getSessions() {
		const sessions = await authClient.listSessions();
		return sessions;
	}

	async function revokeSession(sessionId: string) {
		await authClient.revokeSession({ sessionId });
	}

	async function revokeAllOtherSessions() {
		await authClient.revokeOtherSessions();
	}
</script>
```

---

## Neverthrow Advanced Patterns

### Combining Multiple Results

```typescript
import { combine, combineWithAllErrors } from 'neverthrow';

// Short-circuit on first error
const combined = combine([fetchUser(1), fetchUser(2), fetchUser(3)]);
// Result<[User, User, User], Error>

// Collect all errors
const allResults = combineWithAllErrors([
	validateEmail(email),
	validatePassword(password),
	validateAge(age)
]);
// Result<[void, void, void], ValidationError[]>
```

### Safe JSON Parsing

```typescript
import { fromThrowable } from 'neverthrow';

const safeJsonParse = fromThrowable(JSON.parse, (error) => new Error('Invalid JSON'));

const result = safeJsonParse('{"name":"Alice"}');
// Result<any, Error>
```

### With Async Operations

```typescript
import { ResultAsync } from 'neverthrow';

// Chain async operations
const userResult = ResultAsync.fromPromise(fetch('/api/users/1'), (e) => new Error('Fetch failed'))
	.andThen((response) => ResultAsync.fromPromise(response.json(), (e) => new Error('Parse failed')))
	.map((user) => ({
		...user,
		fullName: `${user.firstName} ${user.lastName}`
	}));
```

---

## TypeScript Tips

### Convex Type Inference

```typescript
// In component
import type { Doc, Id } from '../convex/_generated/dataModel';

// Inferred types
type Post = Doc<'posts'>;
type PostId = Id<'posts'>;

// Use in function
function displayPost(post: Post) {
	console.log(post.title); // Fully typed!
}
```

### Better Auth Types

```typescript
// In app.d.ts
import type { Session, User } from 'better-auth/types';

declare global {
	namespace App {
		interface Locals {
			session: Session | null;
			user: User | null;
		}
		interface PageData {
			user?: User;
		}
	}
}
```

---

## ðŸ“š Additional Resources

- [Svelte 5 Docs](https://svelte.dev/docs/svelte/overview)
- [SvelteKit Docs](https://svelte.dev/docs/kit)
- [Convex Docs](https://docs.convex.dev)
- [Better Auth Docs](https://www.better-auth.com/docs)
- [Runed Docs](https://runed.dev/docs)
- [Neverthrow](https://github.com/supermacro/neverthrow)
- [Bun Docs](https://bun.sh/docs)
